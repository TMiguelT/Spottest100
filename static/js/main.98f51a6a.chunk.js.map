{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["isEligible","track","year","date","Date","album","release_date","eligibilityPeriod","start","end","App","location","useLocation","hash","useMemo","qs","parse","substring","currentYear","getFullYear","useState","uniqueArtists","setUniqueArtists","loginUrl","setLoginUrl","hasRetrieved","setHasRetrieved","shortTerm","setShortTerm","mediumTerm","setMediumTerm","longTerm","setLongTerm","setYear","useEffect","UserHandler","me","then","user","Promise","all","map","term","top","content","tracks","ret","uniqBy","concat","filter","artists","name","client","Client","instance","settings","clientId","scopes","redirect_uri","token","access_token","length","Paper","Grid","container","justify","item","FormGroup","row","TextField","label","type","value","onChange","e","target","FormControlLabel","control","Checkbox","checked","TableContainer","component","Table","style","width","TableHead","TableRow","TableCell","TableBody","i","Link","href","uri","artist","join","CircularProgress","login","url","Button","variant","size","color","maxWidth","Typography","Boolean","window","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.98f51a6a.chunk.js","sourcesContent":["import React, { useState, useMemo, useEffect } from 'react';\nimport './App.css';\nimport { Client, UserHandler } from 'spotify-sdk';\nimport { useLocation } from 'react-router-dom';\nimport qs from 'qs';\nimport Link from '@material-ui/core/Link';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TableRow from '@material-ui/core/TableRow';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport Typography from '@material-ui/core/Typography';\nimport Button from '@material-ui/core/Button';\nimport CircularProgress from '@material-ui/core/CircularProgress';\nimport TextField from '@material-ui/core/TextField';\nimport Checkbox from '@material-ui/core/Checkbox';\nimport FormGroup from '@material-ui/core/FormGroup';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\nimport uniqBy from 'lodash.uniqby';\n\n/**\n * Gets the start and end dates for eligible songs in that year. e.g. for 2019 this would be\n * 1 December 2018 and 30 November 2019\n */\nfunction eligibilityPeriod(year) {\n    return [\n        new Date(year - 1, 11), // December of the previous year\n        new Date(year, 10), // November of the current year\n    ];\n}\n\n/**\n * Returns true if a track is eligible for the given year of hottest 100\n */\nfunction isEligible(track, year) {\n    const date = new Date(track.album.release_date);\n    const [start, end] = eligibilityPeriod(year);\n    return date >= start && date <= end;\n}\n\nfunction App() {\n    const location = useLocation();\n    const hash = useMemo(() => {\n        return qs.parse(location.hash.substring(1));\n    }, [location.hash]);\n    const currentYear = new Date().getFullYear();\n    const [uniqueArtists, setUniqueArtists] = useState(false);\n    const [loginUrl, setLoginUrl] = useState(null);\n    const [hasRetrieved, setHasRetrieved] = useState(false);\n    const [shortTerm, setShortTerm] = useState([]);\n    const [mediumTerm, setMediumTerm] = useState([]);\n    const [longTerm, setLongTerm] = useState([]);\n    const [year, setYear] = useState(currentYear);\n\n    // If we don't yet have the user data, request it\n    useEffect(() => {\n        if (!hasRetrieved) {\n            // Only request once\n            setHasRetrieved(true);\n            new UserHandler().me().then(user => {\n                return Promise.all(['short_term', 'medium_term', 'long_term'].map(term => {\n                    return user.top('tracks', {\n                        'time_range': term,\n                        'limit': 50,\n                    });\n                }));\n            }).then(([shortTerm, mediumTerm, longTerm]) => {\n                setShortTerm(shortTerm);\n                setMediumTerm(mediumTerm);\n                setLongTerm(longTerm);\n            });\n        }\n    }, [hasRetrieved]);\n\n    // Filter the tracks to the top 10, choosing longer term favourites where possible\n    const tracks = useMemo(() => {\n        let ret = uniqBy(\n            longTerm\n                .concat(mediumTerm, shortTerm)\n                .filter(track => isEligible(track, year)),\n            'id',\n        );\n\n        if (uniqueArtists) {\n            // If unique by artist, filter by the first artist who tends to be the main one\n            return uniqBy(ret, track => {\n                return track.artists[0].name;\n            });\n        } else {\n            return ret;\n        }\n\n    }, [shortTerm, mediumTerm, longTerm, year, uniqueArtists]);\n\n    // Set Spotify API settings\n    let client = Client.instance;\n    client.settings = {\n        clientId: '9c91bacd3cc149c4ac198f88b2468719',\n        scopes: ['user-top-read'],\n        redirect_uri: 'http://localhost:8888',\n    };\n\n    let content;\n    if (!('access_token' in hash)) {\n        client.login().then((url) => {\n            setLoginUrl(url);\n        });\n        content = <Button variant={'contained'} size={'large'} color={'primary'}\n            href={loginUrl}>Login</Button>;\n    } else {\n        client.token = hash.access_token;\n        if (tracks.length > 0) {\n            content = <Paper>\n                <Grid container justify={'center'}>\n                    <Grid item>\n                        <FormGroup row>\n                            <TextField\n                                label=\"Year\"\n                                type=\"number\"\n                                value={year}\n                                onChange={e => {\n                                    setYear(e.target.value);\n                                }}\n                            />\n                            <FormControlLabel control={\n                                <Checkbox\n                                    checked={uniqueArtists}\n                                    onChange={e => {\n                                        setUniqueArtists(e.target.checked);\n                                    }}\n                                />\n                            }\n                                label={'Unique Artists'}\n                            />\n                        </FormGroup>\n                    </Grid>\n                </Grid>\n                <TableContainer component={Paper}>\n                    <Table style={{\n                        width: '100%',\n                    }}>\n                        <TableHead>\n                            <TableRow>\n                                <TableCell>Rank</TableCell>\n                                <TableCell>Song</TableCell>\n                                <TableCell>Artists</TableCell>\n                            </TableRow>\n                        </TableHead>\n                        <TableBody>\n                            {\n                                tracks\n                                    .map((track, i) => {\n                                        return (\n                                            <TableRow>\n                                                <TableCell>{i + 1}</TableCell>\n                                                <TableCell>\n                                                    <Link href={track.uri}>\n                                                        {track.name}\n                                                    </Link>\n                                                </TableCell>\n                                                <TableCell>{\n                                                    track.artists.map(artist => artist.name).join(', ')\n                                                }\n                                                </TableCell>\n                                            </TableRow>\n                                        );\n                                    })\n                            }\n                        </TableBody>\n                    </Table>\n                </TableContainer>\n            </Paper>;\n        } else {\n            content = (<CircularProgress/>);\n        }\n    }\n\n    return <Grid container justify={'center'}>\n        <Grid item style={{\n            maxWidth: '800px',\n        }}>\n            <Typography variant={'h1'}>\n                Spotify Hottest 100 Calculator\n            </Typography>\n            {content}\n        </Grid>\n    </Grid>;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport {\n    BrowserRouter as Router,\n} from 'react-router-dom';\n\nReactDOM.render(<Router><App/></Router>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}